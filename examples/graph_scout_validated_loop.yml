# GraphScout with Boolean Validation Loop
# =========================================
#
# This example demonstrates an advanced workflow where GraphScout's path selection
# is iteratively validated and improved using boolean scoring in a loop.
#
# Flow:
# 1. GraphScout proposes an execution path
# 2. PlanValidatorAgent evaluates it with boolean criteria
# 3. If validation fails, GraphScout adjusts and tries again
# 4. Loop continues until path meets quality threshold (0.85)

orchestrator:
  id: validated-graph-scout
  strategy: sequential
  agents:
    - path_discovery_loop
    - final_execution

agents:
  # Iterative path discovery with validation
  - id: path_discovery_loop
    type: loop
    max_loops: 5
    score_threshold: 0.85  # Path must score 85% to proceed
    persist_across_runs: true
    
    # Boolean scoring for deterministic validation
    scoring:
      preset: moderate
      custom_weights:
        # Emphasize completeness and coherence for routing
        completeness.has_all_required_steps: 0.20
        coherence.logical_agent_sequence: 0.05
        coherence.proper_data_flow: 0.03
    
    # Track validation feedback across loops
    past_loops_metadata:
      loop_number: "{{ get_loop_number() }}"
      score: "{{ score }}"
      timestamp: "{{ timestamp }}"
      insights: "{{ insights }}"
      improvements: "{{ improvements }}"
      mistakes: "{{ mistakes }}"
    
    internal_workflow:
      orchestrator:
        id: discovery-validation
        strategy: sequential
        agents: [path_proposer, path_validator_moderate]
      
      agents:
        # GraphScout-style path proposer with validation feedback
        - id: path_proposer
          type: local_llm
          model: gpt-oss:20b
          model_url: http://localhost:11434/api/generate
          provider: ollama
          temperature: 0.7
          prompt: |
            You are GraphScout, an intelligent routing agent. Your task is to propose
            an optimal execution path for the given query.
            
            Query: {{ get_input() }}
            
            {% if get_loop_number() == 1 %}
            ## Initial Path Discovery
            
            Analyze the query and propose an execution path considering:
            
            **Available Agents:**
            - search_agent: Web search capabilities (data_retrieval, web_search)
            - analysis_agent: Deep reasoning and analysis
            - memory_reader: Retrieve relevant past information
            - memory_writer: Store important findings
            - response_builder: Final response generation (answer_emit)
            
            **Requirements:**
            1. Logical agent sequence (dependencies must flow correctly)
            2. Proper data flow between agents
            3. Error handling and fallback paths
            4. Input validation where needed
            5. Edge case handling
            6. Timeout protection for external calls
            
            **Response Format:**
            ```json
            {
              "decision_type": "agent",
              "target": ["agent1", "agent2", "agent3"],
              "reasoning": "Detailed explanation of path selection",
              "data_flow": "How data flows between agents",
              "error_handling": "Strategy for handling failures",
              "edge_cases": "How edge cases are addressed"
            }
            ```
            
            {% else %}
            ## Path Refinement (Loop {{ get_loop_number() }})
            
            Previous attempt scored {{ get_past_loops()[-1].score }} and FAILED validation.
            
            **Failed Criteria:**
            {% if has_past_loops() %}
            {% set last_loop = get_past_loops()[-1] %}
            {{ last_loop.mistakes }}
            {% endif %}
            
            **Validation History:**
            {% for past_loop in get_past_loops() %}
            - Loop {{ past_loop.loop_number }}: Score {{ past_loop.score }}
              Issues: {{ past_loop.improvements }}
            {% endfor %}
            
            **Your Task:**
            Propose an IMPROVED execution path that addresses ALL failed criteria.
            Be specific about how you're fixing each issue.
            
            **Available Agents:**
            - search_agent: Web search (data_retrieval, web_search)
            - analysis_agent: Deep reasoning and analysis
            - memory_reader: Retrieve past information
            - memory_writer: Store findings
            - response_builder: Final response (answer_emit, required for terminal paths)
            
            **Critical Improvements Needed:**
            1. If "has_all_required_steps" failed: Add missing agents
            2. If "includes_fallback_path" failed: Add explicit error handling
            3. If "handles_edge_cases" failed: Specify edge case handling
            4. If "validates_inputs" failed: Add input validation step
            5. If "has_timeout_protection" failed: Specify timeout strategies
            6. If "logical_agent_sequence" failed: Fix agent ordering
            7. If "proper_data_flow" failed: Clarify data dependencies
            
            Respond with the same JSON format as above, with enhanced detail.
            {% endif %}
        
        # Validate the proposed path with boolean scoring
        - id: path_validator_moderate
          type: plan_validator
          llm_model: gpt-oss:20b
          model_url: http://localhost:11434/api/generate
          provider: ollama
          temperature: 0.2
          
          # Boolean scoring configuration
          scoring_preset: moderate
          custom_weights:
            completeness.has_all_required_steps: 0.20
            coherence.logical_agent_sequence: 0.05
            coherence.proper_data_flow: 0.03

  # Execute the validated path
  - id: final_execution
    type: local_llm
    model: gpt-oss:20b
    model_url: http://localhost:11434/api/generate
    provider: ollama
    temperature: 0.3
    prompt: |
      # Validated Path Execution Plan
      
      {% if previous_outputs.path_discovery_loop %}
      {% set loop_result = previous_outputs.path_discovery_loop.response %}
      
      ## Validation Summary
      - Loops Required: {{ previous_outputs.path_discovery_loop.loops_completed }}
      - Final Score: {{ previous_outputs.path_discovery_loop.final_score | round(3) }}
      - Validation Status: {{ 'APPROVED ✓' if previous_outputs.path_discovery_loop.threshold_met else 'FAILED ✗' }}
      
      ## Approved Execution Path
      {% if loop_result.result.path_proposer %}
      {{ loop_result.result.path_proposer.response }}
      {% endif %}
      
      ## Boolean Validation Breakdown
      {% if loop_result.result.path_validator_moderate %}
      {% set validation = loop_result.result.path_validator_moderate %}
      
      **Overall Assessment:** {{ validation.overall_assessment }}
      **Score:** {{ validation.validation_score | round(3) }}
      
      ### Dimension Scores
      {% if validation.dimension_scores %}
      {% for dimension, data in validation.dimension_scores.items() %}
      - {{ dimension|capitalize }}: {{ data.percentage|round(1) }}% ({{ data.score|round(3) }}/{{ data.max_score|round(3) }})
      {% endfor %}
      {% endif %}
      
      ### Passed Criteria ({{ validation.passed_criteria|length }}/15)
      {% for criterion in validation.passed_criteria[:5] %}
      - ✓ {{ criterion }}
      {% endfor %}
      {% if validation.passed_criteria|length > 5 %}
      ... and {{ validation.passed_criteria|length - 5 }} more
      {% endif %}
      
      {% if validation.failed_criteria %}
      ### Failed Criteria ({{ validation.failed_criteria|length }})
      {% for criterion in validation.failed_criteria %}
      - ✗ {{ criterion }}
      {% endfor %}
      {% endif %}
      {% endif %}
      
      ## Evolution Across Loops
      {% if loop_result.past_loops %}
      {% for past_loop in loop_result.past_loops %}
      **Loop {{ past_loop.loop_number }}**: Score {{ past_loop.score }}
      - Issues: {{ past_loop.mistakes or 'None' }}
      {% endfor %}
      {% endif %}
      
      ---
      
      ## Your Task
      Now that we have a validated, high-quality execution path, provide:
      
      1. **Executive Summary**: How the path evolved and improved
      2. **Quality Assessment**: Why this path scored {{ previous_outputs.path_discovery_loop.final_score | round(3) }}
      3. **Key Strengths**: What makes this path robust
      4. **Execution Readiness**: Is it ready for production?
      5. **Recommendations**: Any final suggestions
      
      {% else %}
      No path discovery results available. Unable to proceed.
      {% endif %}

# ============================================================================
# Usage Examples
# ============================================================================
#
# 1. Run with a simple query:
#    orka run graph_scout_validated_loop.yml "What are the latest AI trends?"
#
# 2. Run with a complex query requiring multiple agents:
#    orka run graph_scout_validated_loop.yml "Research quantum computing advances, 
#    analyze their impact on cryptography, and store key findings for future reference"
#
# 3. Observe the validation loop in action:
#    - Watch how GraphScout's proposals improve across iterations
#    - See which boolean criteria fail and get addressed
#    - Track dimension scores (completeness, efficiency, safety, coherence)
#
# 4. Check trace logs for detailed breakdown:
#    - Each loop shows: score, passed_criteria, failed_criteria
#    - Final validation includes dimension_scores and rationale
#    - Evolution summary shows how path quality improved
#
# 5. Adjust validation strictness:
#    - Change score_threshold (line 25): 0.75 (easier) to 0.90 (harder)
#    - Change preset (line 29): lenient → moderate → strict
#    - Add custom_weights (lines 30-34) to emphasize specific criteria
#
# ============================================================================
# Expected Behavior
# ============================================================================
#
# Loop 1: GraphScout proposes initial path
#   → Validator scores it (often 0.60-0.75 on first try)
#   → Identifies missing: edge cases, fallbacks, timeout protection
#
# Loop 2: GraphScout improves path with explicit error handling
#   → Validator scores higher (0.75-0.85)
#   → May still miss: input validation, specific edge cases
#
# Loop 3: GraphScout adds remaining missing pieces
#   → Validator scores 0.85+ 
#   → APPROVED - loop exits
#
# Result: A thoroughly validated execution path with:
#   ✓ All required steps
#   ✓ Edge case handling
#   ✓ Error handling and fallbacks
#   ✓ Input validation
#   ✓ Timeout protection
#   ✓ Logical sequence
#   ✓ Proper data flow

